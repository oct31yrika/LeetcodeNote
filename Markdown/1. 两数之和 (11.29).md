# 1. 两数之和 (11.29)

### ①. 自己的算法

* 初始想法是首先创建一个字典对索引和nums里的数字对应，之后复制nums，并对复制后的列表进行排序。

* 对排序后的列表，从第一个数字开始，去和自己后面的数字挨个配对，如果结果match则查找对应索引并返回，如果结果大于target则停止搜寻换下一个数字。
* <span data-type="text" style="color: var(--b3-font-color8);">核心问题仍然是当数组是 {3,3} 这样的重复数字，如何规避掉匹配到自己。</span>

<span data-type="text" style="background-color: var(--b3-card-success-background); color: var(--b3-card-success-color);">正确：</span>想到双指针那样通过排序来节省枚举的思路了。

<span data-type="text" style="background-color: var(--b3-card-error-background); color: var(--b3-card-error-color);">错误：</span>没有考虑到双循环的时间复杂度仍然是O(n)。且根据value去找key在c++里太麻烦了，特别是好几个value是相同的情况下，最终没能实现。

---

### ②. 方法

**Brute Force**

算法：遍历每个元素x，并且去找哪个是否有另一个值等于target - 1。

代码：

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        for (int i = 0; i < nums.size(); i++) {
            for (int j = i + 1; j < nums.size(); j++) {
                if (nums[j] == target - nums[i]) {
                    return {i, j};
                }
            }
        }
        // Return an empty vector if no solution is found
        return {};
    }
};
```

复杂度分析：

时间复杂度：O(n<sup>2</sup>)

空间复杂度：O(1) | 需要的空间不依赖于输入的数组大小，所以只有constant space被使用。

---

**Two-Pass Hash Table**

启发：<span data-type="text" style="background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);">最好维持每个元素与其index的mapping的方式是hash table。</span>

我们可以通过牺牲空间来换取速度，从而将查找时间从 O(n) 降低到 O(1)。哈希表非常适合用于此目的，因为它支持接近常数时间的快速查找。之所以说是“接近”，是因为如果发生冲突，查找时间可能会退化到 O(n)。但是，只要哈希函数选择得当，哈希表中的查找时间通常可以摊销为 O(1)。

‍

算法：两次迭代

在第一次迭代中，我们将每个元素的<u>digit</u>作为key，其<u>index</u>作为value添加到哈希表中。然后在第二次迭代中，我们检查每个元素的补集（target-nums[i]）是否存在于哈希表中。如果存在，则返回当前元素的index及其补集的index。注意，补集不能是 nums[i] 本身！

‍

代码：

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        unordered_map<int, int> hash;
        for (int i = 0; i < nums.size(); i++) {
            hash[nums[i]] = i;
        }
        for (int i = 0; i < nums.size(); i++) {
            int complement = target - nums[i];
            if (hash.find(complement) != hash.end() && hash[complement] != i) {   // flag🚩
                return {i, hash[complement]};
            }
        }
        // If no valid pair is found, return an empty vector
        return {};
    }
};
```

字典最大的特性是键值对应，因此首先想到的是拿独一无二的index作为key（查找很困难）。

用digit作为key，特性是当数组里有重复的digit的时候，遍历法使得字典里只能记住该digit**最后出现的位置**。

然而巧妙的是，查找的时候，顺序也是 i 先等于digit**首次出现的位置**，如果数组里有两个相同的digit，理论上只会匹配到不同于i的index。

‍

复杂度分析：

时间复杂度：O(n)

空间复杂度：O(n) | 所需的额外空间取决于哈希表中存储的item数量，哈希表恰好存储 n 个元素。

---

**One-pass Hash Table**

算法：一次遍历完成

在遍历哈希表并向其中插入元素的同时，我们也会回溯检查当前元素的补集是否已存在于哈希表中。如果存在，我们就找到了解决方案，并立即返回索引。<span data-type="text" style="background-color: var(--b3-card-warning-background); color: var(--b3-card-warning-color);">这个方法不会匹配到自己。</span>

‍

代码：

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int> &nums, int target) {
        unordered_map<int, int> hash;
        for (int i = 0; i < nums.size(); ++i) {
            int complement = target - nums[i];
            if (hash.find(complement) != hash.end()) {
                return {hash[complement], i};
            }
            hash[nums[i]] = i;
        }
        // Return an empty vector if no solution is found
        return {};
    }
};
```

‍

复杂度分析：

时间复杂度：O(n)

空间复杂度：O(n) | 所需的额外空间取决于哈希表中存储的item数量，哈希表最多存储 n 个元素。

---

**Two Pointers**

看完哈希表法后觉得双指针O(nlogn)也不太明智，所以不记了。

大概是拿了两个匹配的数字，然后遍历原始列表去找他们对应的index。

如果是 {3,3} 这样的数组，第一个3匹配上并记下index，第二次匹配时避开这个index即可。

‍
